#重构

不要把重构当做先写后改的代名词
避免用重构代替重写
 

###重构的理由
 
* 代码重复
* 冗长的子程序：提升模块性，增加定义完善、命名准确的子程序，让它们各自集中力量做好一件事。
* 循环过长或嵌套过深：循环内部的复杂代码通常具有转换为子程序的潜质。
* 内聚性太差的类：每个类负责一组具有内在关联的任务。
* 拥有太多参数的参数列表：长长的参数列表是在警告程序员的子程序接口抽象未经斟酌。
* 变化导致多个类的相同修改
* 同时使用的相关数据并未以类的方式进行组织
* 某个类无所事事：如果一个类看起来名不副实，看看能否把功能转交给其他类，然后彻底去掉这个类。
* 某个类同其他类的关系过于亲密
* 子程序命名不当
* 数据成员被设置为public
* 使用了全局变量
* 在子程序调用前使用了设置代码，或在调用后使用了收尾代码：想想这个子程序的接口是否体现了正确的抽象。
 
 
###特定的重构
 
####数据集的重构
* 用常量名代替神秘数值
* 使变量名更为清晰且传递更多信息
* 将表达式内联化：把一个中间变量换成给它赋值的表达式本身。
* 用函数代替表达式
* 将一组类型码转化为类或枚举类型
* 把collection封装起来：到处散布的多个collection实例会带来同步问题。让类返回一个只读collection，并且提供相应的为collection添加和删除元素的子程序。
 
####语句级重构
 
* 分解布尔表达式
* 合并条件语句不同部分中的重复代码片段
* 用多态来替代条件语句

####子程序级重构

* 将查询操作从修改操作中独立出来
* 包装向下转型操作
* 提取vs内联 加参数vs去参数 合并vs拆分 传递对象vs传递每个成员

####类实现重构

* 将值对象转化为引用对象：如果发现自己创建并维护多个一模一样的大型对象
* 将引用对象转化为值对象
* 将像似代码结合起来放置到基类中
* 将特殊代码提取为派生类：如果类的一部分代码仅被某部分实例使用

####类接口重构

* 将一个类变成两个
* 删除类
* 去除委托关系
* 去掉中间人：A调用B，B调用C -> A直接调用C
* 用委托代替继承
* 用继承代替委托：如果某个类公开了委托类所有的成员函数，改成继承。

####系统级重构

* 用Factory Method而不是简单的构造函数：当1.需要类型码创建对象；2.使用引用对象而不是值对象。
* 用异常取代错误处理代码，或相反。


###安全的重构

* 保存初始代码
* 同一时间只做一项重构
* 把要做的事一条条列出来
* 多使用检查点
* 重新测试
